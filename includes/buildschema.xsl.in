<?xml version='1.0'?>

<!--

Copyright 2013 Double Precision, Inc.
See COPYING for distribution information.

-->

<xsl:stylesheet  
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

  <xsl:output method="text" />

  <xsl:param name="mode" />

  <!-- Class name override from @class, default to @name -->

  <xsl:template name="class">
    <xsl:choose>
      <xsl:when test="@class">
	<xsl:value-of select="@class" />
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="@name" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Base name of the join. Default to @class, unless explicit @name is given -->

  <xsl:template name="joinname">
    <xsl:choose>
      <xsl:when test="@name">
	<xsl:value-of select="@name" />
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="@class" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!--
      Figure out the datatype of this column, for field<> declaration.

      Used to declare field<type> columns for a table's
      resultset's row object.
  -->

  <xsl:template name="get-datatype">
    <xsl:choose>
      <xsl:when test="@datatype">
	<xsl:value-of select="@datatype" />
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>std::string</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!--
      Get the name of the foreign key's column in the foreign table.

      Same as the column name, but gets overriden by @foreigncolumn.
  -->

  <xsl:template name="get-foreign-column-name">
    <xsl:choose>
      <xsl:when test="@foreigncolumn">
	<xsl:value-of select="@foreigncolumn" />
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="." />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Open/close namespace declaration -->
  <xsl:template name="namespacedecl">
    <xsl:param name="namespace" />
    <xsl:param name="context" />

    <xsl:if test="$namespace">
      <xsl:choose>
	<xsl:when test="contains($namespace, '::')">
	  <xsl:call-template name="namespacedeclemit">
	    <xsl:with-param name="namespace" select="substring-before($namespace, '::')" />
	    <xsl:with-param name="context" select="$context" />
	  </xsl:call-template>

	  <xsl:call-template name="namespacedecl">
	    <xsl:with-param name="namespace" select="substring-after($namespace, '::')" />
	    <xsl:with-param name="context" select="$context" />
	  </xsl:call-template>
	  
	</xsl:when>
	<xsl:otherwise>
	  <xsl:call-template name="namespacedeclemit">
	    <xsl:with-param name="namespace" select="$namespace" />
	    <xsl:with-param name="context" select="$context" />
	  </xsl:call-template>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>

  <xsl:template name="namespacedeclemit">
    <xsl:param name="namespace" />
    <xsl:param name="context" />

    <xsl:choose>
      <xsl:when test="$context = 'open'">
	<xsl:text>namespace </xsl:text>
	<xsl:value-of select="$namespace" />
	<xsl:text> {&#10;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>};&#10;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Top-level node -->

  <xsl:template match="/schema">

    <xsl:text>//! \file

// AUTOGENERATED -- do not edit&#10;&#10;</xsl:text>

    <xsl:choose>
      <xsl:when test="$mode= 'decl'">
	<xsl:text>#include &lt;@LIBCXX_NAMESPACE@/ref.H&gt;
#include &lt;@LIBCXX_NAMESPACE@/refiterator.H&gt;
#include &lt;@LIBCXX_NAMESPACE@/sql/dbi/resultset.H&gt;

// Forward declarations

</xsl:text>

	<xsl:call-template name="namespacedecl">
	  <xsl:with-param name="namespace" select="@namespace" />
	  <xsl:with-param name="context" select="'open'" />
	</xsl:call-template>

        <!--
	    Forward declaration: [name]rowObj, [name]Obj, and nameBase.
	    Then generate the ref, ptr, const_ref, and const_ptr typedefs.
	-->

        <xsl:for-each select="table">
	  <xsl:text>class </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>Obj;
class </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>_JoinsObj;
class </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>Base;

</xsl:text>
        </xsl:for-each>

	<xsl:text>
// Resultset classes and base classes
</xsl:text>

        <xsl:for-each select="table">
	  <xsl:text>
//! The \c </xsl:text>
          <xsl:call-template name="class" />
	  <xsl:text> table resulset

typedef @LIBCXX_NAMESPACE@::ref&lt;</xsl:text>
          <xsl:call-template name="class" />
	  <xsl:text>Obj, </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>Base&gt; </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>;

//! A constant reference to a \c </xsl:text>
          <xsl:call-template name="class" />
          <xsl:text> table resulset

typedef @LIBCXX_NAMESPACE@::const_ref&lt;</xsl:text>
          <xsl:call-template name="class" />
	  <xsl:text>Obj, </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>Base&gt; const_</xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>;

//! A nullable pointer reference to a \c </xsl:text>
          <xsl:call-template name="class" />
          <xsl:text> table resulset

typedef @LIBCXX_NAMESPACE@::ptr&lt;</xsl:text>
          <xsl:call-template name="class" />
          <xsl:text>Obj, </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>Base&gt; </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>ptr;

//! A nullable pointer reference to a constant \c </xsl:text>
          <xsl:call-template name="class" />
	  <xsl:text> table resulset

typedef @LIBCXX_NAMESPACE@::const_ptr&lt;</xsl:text>
          <xsl:call-template name="class" />
	  <xsl:text>Obj, </xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>Base&gt; const_</xsl:text>
	  <xsl:call-template name="class" />
	  <xsl:text>ptr;

</xsl:text>
        </xsl:for-each>

	<xsl:text>
// Base classes
</xsl:text>

        <xsl:for-each select="table">

	  <xsl:text>
//! Base class for \c </xsl:text>
          <xsl:call-template name="class" />
	  <xsl:text> resultsets

//! Refer to this class as </xsl:text>
          <xsl:call-template name="class" />
          <xsl:text>::base

class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base : public @LIBCXX_NAMESPACE@::ptrrefBase {

public:

    class rowObj;

    class prefetchedrowObj;

    class iteratorObj;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::row - a reference to a row in the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::ref&lt;rowObj&gt; row;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::rowptr - a nullable pointer reference to a row in the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::ptr&lt;rowObj&gt; rowptr;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::const_row - a reference to a constant row in the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::const_ref&lt;rowObj&gt; const_row;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::const_rowptr - a nullable pointer reference to a constant row in the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::const_ptr&lt;rowObj&gt; const_rowptr;

//! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::iterator - Iterator returned by begin() and end() </xsl:text>
    <xsl:text>

    typedef @LIBCXX_NAMESPACE@::refiterator&lt;iteratorObj&gt; iterator;

//! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::iteratorptr - Nullable iterator value returned by begin() and end()</xsl:text>

    <xsl:text>

    typedef @LIBCXX_NAMESPACE@::ptriterator&lt;iteratorObj&gt; iteratorptr;

//! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::const_iterator - Constant iterator value returned by begin() and end()</xsl:text>
    <xsl:text>

    typedef @LIBCXX_NAMESPACE@::const_refiterator&lt;iteratorObj&gt; const_iterator;

//! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::const_iteratorptr - Nullable iterator value returned by begin() and end() </xsl:text>
    <xsl:text>

    typedef @LIBCXX_NAMESPACE@::const_ptriterator&lt;iteratorObj&gt; const_iteratorptr;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::joins - a reference to joins from the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::ref&lt;</xsl:text>
    <xsl:call-template name="class" /><xsl:text>_JoinsObj&gt; joins;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::joinsptr - a nullable pointer reference to joins from the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::ptr&lt;</xsl:text>
    <xsl:call-template name="class" /><xsl:text>_JoinsObj&gt; joinsptr;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::const_joins - a reference to constant joins from the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::const_ref&lt;</xsl:text>
    <xsl:call-template name="class" /><xsl:text>_JoinsObj&gt; const_joins;

    //! </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::const_joinsptr - a nullable pointer reference to constant joins from the \c </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>table

    typedef @LIBCXX_NAMESPACE@::const_ptr&lt;</xsl:text>
    <xsl:call-template name="class" /><xsl:text>_JoinsObj&gt; const_joinsptr;

    //! A reference to a prefetched row.

    typedef @LIBCXX_NAMESPACE@::ref&lt;prefetchedrowObj&gt; prefetchedrow;

    //! A nullable pointer reference to a prefetched row.

    typedef @LIBCXX_NAMESPACE@::ptr&lt;prefetchedrowObj&gt; prefetchedrowptr;

    //! A reference to a constant prefetched row.

    typedef @LIBCXX_NAMESPACE@::const_ref&lt;prefetchedrowObj&gt; const_prefetchedrow;

    //! A nullable pointer reference to a constant prefetched row.

    typedef @LIBCXX_NAMESPACE@::ptr&lt;prefetchedrowObj&gt; const_prefetchedrowptr;
};

</xsl:text>
	</xsl:for-each>

        <xsl:apply-templates select="table" mode="decl" />
      </xsl:when>

      <xsl:when test="$mode= 'impl'">
	<xsl:call-template name="namespacedecl">
	  <xsl:with-param name="namespace" select="@namespace" />
	  <xsl:with-param name="context" select="'open'" />
	</xsl:call-template>

	<xsl:apply-templates select="table" mode="impl" />
      </xsl:when>
    </xsl:choose>

    <xsl:call-template name="namespacedecl">
      <xsl:with-param name="namespace" select="@namespace" />
      <xsl:with-param name="context" select="'close'" />
    </xsl:call-template>
  </xsl:template>

  <!-- Declare a resultset class for one table -->

  <xsl:template match="table" mode="decl">
    <xsl:text>//! Joins for the \c </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text> resultset object&#10;&#10;class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj : public @LIBCXX_NAMESPACE@::sql::dbi::joinBaseObj {

public:

    //! The table columns

    static const char * const columns[];

    //! Return table columns

    const char * const *get_table_columns() const override;

    </xsl:text>

    //! Constructor

    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj();

    //! Destructor

    ~</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj() noexcept;
</xsl:text>

    <xsl:for-each select="join">
      <xsl:text>

    //! Create a join to the </xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text> table on columns: </xsl:text>

      <xsl:for-each select="column">
	<xsl:if test="position() &gt; 1">
	  <xsl:text>, </xsl:text>
	</xsl:if>

	<xsl:value-of select="." />
      </xsl:for-each>
      <xsl:text>
    virtual </xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text>::base::joins join_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>()=0;
</xsl:text>
    </xsl:for-each>
    <xsl:text>

    //! Prefetch rows from this join

    </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::prefetchedrow prefetch();

private:

    //! Return the connection object that was used to create this join.

    //! Used by prefetch() to retrieve the connection object from the subclass
    //! so that it can instantiated the prefetchedrow object.

    virtual @LIBCXX_NAMESPACE@::sql::connection getConnection()=0;
};

//! The \c </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text> resultset object&#10;&#10;class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj : public @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj, public </xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj {

//! The table alias in the resultset

    std::string alias;

public:

    //! Resultset constructor

    </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj(const @LIBCXX_NAMESPACE@::sql::connection &amp;conn);

    //! Additional resultset constructed by a join

    </xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Obj(const @LIBCXX_NAMESPACE@::sql::connection &amp;conn, const @LIBCXX_NAMESPACE@::ref&lt;aliasesObj&gt; &amp;aliasesArg);

    //! Destructor
    </xsl:text>
    ~<xsl:call-template name="class" />
    <xsl:text>Obj() noexcept;

private:
    //! This table's name

    static const char table_name[];

public:
    //! Return this table's name;

    const char *get_table_name() const override;

    //! This table's alias

    std::string get_table_alias() const override;

    //! Table's primary keys

    static const char * const primarykeycolumns[];

    //! Return table's primary key columns

    const char * const *get_primary_key_columns() const override;

    //! Table's serial keys

    static const char * const serialkeycolumns[];

    //! Return table's serial primary key column(s)

    const char * const *get_serial_key_columns() const override;

    friend class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::rowObj;

    friend class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorObj;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::iterator iterator;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorptr iteratorptr;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::const_iterator const_iterator;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::const_iteratorptr const_iteratorptr;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::row row;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::rowptr rowptr;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::const_row const_row;

    //! Convenience typedef

    typedef </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::const_rowptr const_rowptr;

    //! Execute a SELECT on this resultset, return the beginning iterator for the sequence.

    //! The maximum number of rows is set by calling limit(), previously.
    iterator begin() const;

    //! Execute a SELECT on this resultset, return the beginning iterator for the sequence.

    //! The maximum number of rows is given explicitly
    iterator begin(size_t limitvalue) const;

    //! Return ending iterator value for a SELECT sequence

    iterator end() const;

    //! Return the sole row possibly expected from a SELECT on this resultset.

    //! Uses begin(2), and throws an exception if the SELECT returns a second
    //! row. Returns a null pointer reference if SELECT returned no rows.

    rowptr maybe() const;

    //! Return the sole row definitely expected from a SELECT on this resultset.

    //! Calls maybe(), and throws an exception if maybe() returns an empty
    //! pointer.

    row only() const;

private:

    //! Resultset implementation subclass forwards this to its create_column_list()

    void resultset_create_column_list(std::vector&lt;std::string&gt; &amp;columns) const override;

    //! Add additional joins to the resultset

    //! Used by get_search_sql() to recursively add joins to joins.

    void get_join_sql_recursive(std::ostream &amp;) const override;

    //! Invoke join_prefetch_column_list()

    void prefetch_column_list_recursive(std::vector&lt;std::string&gt; &amp;list) const override;

    //! Invoke join_bind_prefetched_row()
    void bind_prefetched_recursive(std::vector&lt;@LIBCXX_NAMESPACE@::sql::bindrowimpl&gt; &amp;list) const override;
public:

    //! Used by prefetch() to retrieve the connection object.

    @LIBCXX_NAMESPACE@::sql::connection getConnection() override;

    //! Insert a new row

    template&lt;typename ...Args&gt;
    inline row insert(Args &amp;&amp; ...args)
    {
        auto rs=</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::create(conn);

	auto insert_constraints=@LIBCXX_NAMESPACE@::ref&lt;@LIBCXX_NAMESPACE@::sql::dbi::constraintObj::andObj&gt;::create();

        {
            auto values=@LIBCXX_NAMESPACE@::ref&lt;@LIBCXX_NAMESPACE@::sql::dbi::constraintObj::andObj&gt;::create();

            @LIBCXX_NAMESPACE@::sql::dbi::get_updins_list(values, std::forward&lt;Args&gt;(args)...);

            do_insert(rs-&gt;insert_sql, insert_constraints, rs->where, values);
        }

	rs-&gt;insert_select_constraint=insert_constraints;
        return rs-&gt;only();
    }
</xsl:text>

    <xsl:for-each select="join">
      <xsl:text>

    //! Create a join to the </xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text> table on columns: </xsl:text>

      <xsl:for-each select="column">
	<xsl:if test="position() &gt; 1">
	  <xsl:text>, </xsl:text>
	</xsl:if>

	<xsl:value-of select="." />
      </xsl:for-each>
      <xsl:text>
    </xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text>::base::joins join_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() override;
</xsl:text>
    </xsl:for-each>
    <xsl:text>
};

//! A reference-counted object representing a row in this table

class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::rowObj : public @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::rowObj {

public:

    friend class iteratorObj;

    //! Constructor

    rowObj(const @LIBCXX_NAMESPACE@::sql::connection &amp;conn);

    //! Destructor

    ~rowObj() noexcept;
</xsl:text>

    <!-- Emit column declarations -->

    <xsl:for-each select="column">

      <xsl:text>
//! Column

    @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::rowObj::field&lt;</xsl:text>

      <xsl:call-template name="get-datatype" />
      <xsl:text>&gt; </xsl:text>
      <xsl:value-of select='@name' />
      <xsl:text>;&#10;</xsl:text>
    </xsl:for-each>

    <!-- Emit resultset joins -->

    <xsl:for-each select="join">
      <xsl:text>

    //! Create a new resultset based on a join to the </xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text> table on columns: </xsl:text>

      <xsl:for-each select="column">
	<xsl:if test="position() &gt; 1">
	  <xsl:text>, </xsl:text>
	</xsl:if>

	<xsl:value-of select="." />
      </xsl:for-each>

      <xsl:text>
    </xsl:text>
      <xsl:value-of select="@class" />

      <xsl:text> join_rs_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() const;

    //! Retrieve the only row possibly expected from a join to the </xsl:text>
      <xsl:value-of select="@class" />
      <xsl:text> table on columns: </xsl:text>

      <xsl:for-each select="column">
	<xsl:if test="position() &gt; 1">
	  <xsl:text>, </xsl:text>
	</xsl:if>

	<xsl:value-of select="." />
      </xsl:for-each>
      <xsl:text>

    </xsl:text>
      <xsl:value-of select="@class" />

      <xsl:text>::base::rowptr join_maybe_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() const;

    //! Retrieve the only row definitely from a join to the </xsl:text>
      <xsl:value-of select="@class" />
      <xsl:text> table on columns: </xsl:text>

      <xsl:for-each select="column">
	<xsl:if test="position() &gt; 1">
	  <xsl:text>, </xsl:text>
	</xsl:if>

	<xsl:value-of select="." />
      </xsl:for-each>
      <xsl:text>

    </xsl:text>
      <xsl:value-of select="@class" />

      <xsl:text>::base::row join_only_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() const;

      //! Execute the join to the </xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text> table on columns: </xsl:text>

      <xsl:for-each select="column">
	<xsl:if test="position() &gt; 1">
	  <xsl:text>, </xsl:text>
	</xsl:if>

	<xsl:value-of select="." />
      </xsl:for-each>

      <xsl:text>

    inline </xsl:text>

      <xsl:value-of select="@class" />
      <xsl:choose>
	<xsl:when test="@maybe">
	  <xsl:text>::base::rowptr</xsl:text>
	</xsl:when>
        <xsl:when test="@only">
	  <xsl:text>::base::row</xsl:text>
        </xsl:when>
      </xsl:choose>
      <xsl:text> join_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() const
    {
        return join</xsl:text>
      <xsl:choose>
	<xsl:when test="@maybe">
	  <xsl:text>_maybe_</xsl:text>
	</xsl:when>
        <xsl:when test="@only">
	  <xsl:text>_only_</xsl:text>
        </xsl:when>
	<xsl:otherwise>
	  <xsl:text>_rs_</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
      <xsl:call-template name="joinname" />
      <xsl:text>();
    }

private:

    //! Cached joined row

    mutable @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::rowObj::cached_row&lt;</xsl:text>
      <xsl:value-of select="@class" />
      <xsl:text>::base::rowptr&gt; join_row_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>;

public:
</xsl:text>

    </xsl:for-each>
    <xsl:text>

    //! Update this row

    //! Returns true if the row was updated, false if the row was unchanged.
    //! An exception gets thrown if the schema's primary keys are wrong.

    bool update();

    friend class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::prefetchedrowObj;

private:
    //! This row has been fetched. Preserve all .scalar in .original

    void fetched_this_row();
};

//! A new row factory, used by iteratorObj to create new rows.

//! Also returned by join handles' prefetch(), where a prefetched row may be
//! retrieved from.

class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::prefetchedrowObj : public @LIBCXX_NAMESPACE@::sql::bindrowimplObj {

    //! Our omniscient connection

    @LIBCXX_NAMESPACE@::sql::connection conn;

    //! The next row being fetched

    </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::row next_row;

    //! Whether next_row has been used, or not.

    //! The constructor creates a new next_row. First call to bind() uses
    //! it, subsequent calls create a new next_row.

    bool first;

public:

    //! Current row

    </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::row row;

    friend class iteratorObj;

    friend class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinObj;

public:
    //! Constructor
    prefetchedrowObj(const @LIBCXX_NAMESPACE@::sql::connection &amp;connArg);

    //! Destructor
    ~prefetchedrowObj() noexcept;

private:

    //! Bind next row
    void bind(@LIBCXX_NAMESPACE@::sql::bindrow::consecutive &amp;factory) override;

    //! The row was fetched
    void fetched();
};


//! A reference-counted iterator object, over the resultset

class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorObj : virtual public @LIBCXX_NAMESPACE@::obj {

    //! Current row

    @LIBCXX_NAMESPACE@::ref&lt;</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::prefetchedrowObj&gt; current_row;

    //! All rows, this one and any prefetched ones.

    @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::bindrow_all all_rows;

    //! The executed SELECT statement

    @LIBCXX_NAMESPACE@::sql::statementptr statement;

    //! The resultset this iterator came from

    </xsl:text>
    const_<xsl:call-template name="class" />
    <xsl:text> resultset;

public:
    friend class </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj;

    //! This is an input iterator

    typedef std::input_iterator_tag iterator_traits;

public:
    //! Beginning iterator constructor

    //! The resultset's begin() create()s this object using this constructor.
    //! We get the executed statement object, and the resultset that created
    //! this iterator.

    iteratorObj(const @LIBCXX_NAMESPACE@::sql::statement &amp;statementArg, const const_</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text> &amp;resultsetArg);

    //! Ending iterator constructor

    //! The resultset's end() create()s this object using this constructor.

    iteratorObj(const </xsl:text>
    const_<xsl:call-template name="class" />
    <xsl:text> &amp;resultsetArg);

    //! Destructor

    ~iteratorObj() noexcept;

    //! The * operator

    inline const </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::row &amp;operator*() const
    {
        *statement; // Ending iterator value check.
        return current_row-&gt;row;
    }

    //! Fetch next row

    void operator++()
    {
        if (!statement-&gt;fetch(all_rows))
        {
            // No more rows
            statement=@LIBCXX_NAMESPACE@::sql::statementptr();
            return;
        }

        for (const auto &amp;row:all_rows.rows)
            row-&gt;fetched();
    }

    //! Two ending iterator values compare equal, anything else doesn't

    inline bool operator==(const iteratorObj &amp;o) const
    {
        return statement.null() &amp;&amp; o.statement.null();
    }

    //! Two ending iterator values compare equal, anything else doesn't

    inline bool operator!=(const iteratorObj &amp;o) const
    {
        return !operator==(o);
    }

private:

    //! Helper class used by before_postoper()
    class postoper_helper {

        //! Saved row

        </xsl:text>
        <xsl:call-template name="class" />
        <xsl:text>::base::row saved_row;

    public:
        //! Constructor
        inline postoper_helper(const </xsl:text>
        <xsl:call-template name="class" />
        <xsl:text>::base::row &amp; saved_rowArg) : saved_row(saved_rowArg) {}

        </xsl:text>
        inline <xsl:call-template name="class" />
        <xsl:text>::base::row operator*() const { return saved_row; }
    };

public:
    //! Called by refobjiterator's postfix++ before it calls my operator++()

    postoper_helper before_postoper();
};

</xsl:text>
  </xsl:template>

  <!-- Implement a resultset class for a table -->

  <xsl:template match="table" mode="impl">

    <!-- Join base class constructor, destructor -->

    <xsl:text>&#10;</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj::</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj()
{
}
</xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj::~</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj() noexcept {}

const char * const </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj::columns[]={&#10;</xsl:text>

    <xsl:for-each select="column">
      <xsl:text>        "</xsl:text>
      <xsl:call-template name="class" />
      <xsl:text>",&#10;</xsl:text>
    </xsl:for-each>

    <xsl:text>        nullptr
};

const char * const *</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj::get_table_columns() const { return columns; }

</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::prefetchedrow </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>_JoinsObj::prefetch()
{
    auto newrow=</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::prefetchedrow::create(getConnection());

    install_prefetch(newrow);

    return newrow;
}

    </xsl:text>

    <!-- Resultset Constructor -->
    <xsl:call-template name="class" />
    <xsl:text>Obj::</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj(const @LIBCXX_NAMESPACE@::sql::connection &amp;conn, const @LIBCXX_NAMESPACE@::ref&lt;aliasesObj&gt; &amp;aliasesArg)
    : @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj(conn, aliasesArg), alias(aliases-&gt;get_alias(table_name))
{
}

</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj(const @LIBCXX_NAMESPACE@::sql::connection &amp;conn)
    : @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj(conn), alias(aliases-&gt;get_alias(table_name))
{
}
</xsl:text>

    <!-- Destructor -->
    <xsl:call-template name="class" />
    <xsl:text>Obj::~</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj() noexcept {}

const char </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::table_name[]="</xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>";

const char *</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::get_table_name() const { return table_name; }

std::string </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::get_table_alias() const { return alias; }

const char * const </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::primarykeycolumns[]={&#10;</xsl:text>

    <xsl:for-each select="column">
      <xsl:if test="@primarykey">
	<xsl:text>        columns[</xsl:text>
	<xsl:value-of select="position()-1" />
	<xsl:text>],&#10;</xsl:text>
      </xsl:if>
    </xsl:for-each>

    <xsl:text>        nullptr
};

const char * const *</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::get_primary_key_columns() const { return primarykeycolumns; }

const char * const </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::serialkeycolumns[]={&#10;</xsl:text>

    <xsl:for-each select="column">
      <xsl:if test="@primarykey = 'serial'">
	<xsl:text>        columns[</xsl:text>
	<xsl:value-of select="position()-1" />
	<xsl:text>],&#10;</xsl:text>
      </xsl:if>
    </xsl:for-each>

    <xsl:text>        nullptr
};

const char * const *</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::get_serial_key_columns() const { return serialkeycolumns; }

</xsl:text>

    <!-- Resultset begin() implementation -->
    <xsl:call-template name="class" />
    <xsl:text>Obj::iterator </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::begin() const
{
    return begin(this-&gt;maxrows);
}

void </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::resultset_create_column_list(std::vector&lt;std::string&gt; &amp;columns) const
{
    create_columns_list(columns);
}

</xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Obj::iterator </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::begin(size_t limitvalue) const
{
    auto statement=execute_search_sql(limitvalue);

    auto iter=iterator::create(statement, const_</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>(this));

    iter.get()-&gt;operator++(); // Fetch the first row into the iterator.

    return iter;
}

</xsl:text>

    <!-- Resultset end() implementation -->

    <xsl:call-template name="class" />
    <xsl:text>Obj::iterator </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::end() const
{
    return iterator::create(</xsl:text>
    const_<xsl:call-template name="class" />
    <xsl:text>(this));
}

</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::rowptr </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::maybe() const
{
    rowptr r;

    auto b=begin(2), e=end();

    if (b != e)
    {
        r= *b;
        if (++b != e)
            @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::multiple_rows();
    }

    return r;
}

</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::row </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Obj::only() const
{
    auto row=maybe();

    if (row.null())
       @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::no_rows();

    return row;
}

void </xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Obj::get_join_sql_recursive(std::ostream &amp;o) const
{
    get_join_sql(o);
}

void </xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Obj::prefetch_column_list_recursive(std::vector&lt;std::string&gt; &amp;list) const
{
    join_prefetch_column_list(list);
}

void </xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Obj::bind_prefetched_recursive(std::vector&lt;@LIBCXX_NAMESPACE@::sql::bindrowimpl&gt; &amp;list) const
{
    join_bind_prefetched_row(list);
}

@LIBCXX_NAMESPACE@::sql::connection </xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Obj::getConnection()
{
    return conn;
}
</xsl:text>

    <xsl:variable name="class">
      <xsl:call-template name="class" />
    </xsl:variable>

    <xsl:for-each select="join">

        <xsl:value-of select="@class" />
	<xsl:text>::base::joins </xsl:text>
	<xsl:value-of select="$class" />
	<xsl:text>Obj::join_</xsl:text>
	<xsl:call-template name="joinname" />
	<xsl:text>()
{
    auto newjoin=</xsl:text>
        <xsl:value-of select="@class" />
        <xsl:text>::create(conn, aliases);
    addjoin("</xsl:text>
        <xsl:choose>
	  <xsl:when test="@type">
	    <xsl:value-of select="@type" />
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:text>LEFT JOIN</xsl:text>
	  </xsl:otherwise>
	</xsl:choose>
        <xsl:text>", newjoin, {
</xsl:text>
        <xsl:for-each select="column">
          <xsl:if test="position() &gt; 1">
	    <xsl:text>,&#10;</xsl:text>
	  </xsl:if>
	  <xsl:text>        "</xsl:text>
	  <xsl:value-of select="." />
	  <xsl:text>", "</xsl:text>
	  <xsl:call-template name="get-foreign-column-name" />
	  <xsl:text>"</xsl:text>
	</xsl:for-each>
    <xsl:text>
    });
	    
    return newjoin;
}
</xsl:text>
    </xsl:for-each>

    <!-- New row factory code -->

    <xsl:call-template name="class" />
    <xsl:text>Base::prefetchedrowObj::prefetchedrowObj(const @LIBCXX_NAMESPACE@::sql::connection &amp;connArg) : conn(connArg), next_row(</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::row::create(conn)), first(true), row(next_row)
{
}
</xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Base::prefetchedrowObj::~prefetchedrowObj() noexcept
{
}

void </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::prefetchedrowObj::bind(@LIBCXX_NAMESPACE@::sql::bindrow::consecutive &amp;factory)
{
    if (!first)
    {
        next_row=</xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>::base::row::create(conn);
    }

    first=false;

</xsl:text>
    <xsl:for-each select="column">
      <xsl:text>    factory.bind(next_row-&gt;</xsl:text>
      <xsl:value-of select="@name" />
      <xsl:text>.scalar);
</xsl:text>
    </xsl:for-each>
<xsl:text>}

void </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::prefetchedrowObj::fetched()
{
    row=next_row;
    row-&gt;fetched_this_row();
}
</xsl:text>

    <!-- Iterator code -->

    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorObj::iteratorObj(const @LIBCXX_NAMESPACE@::sql::statement &amp; statementArg, const const_</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text> &amp;resultsetArg)
        : current_row(@LIBCXX_NAMESPACE@::ref&lt;</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::prefetchedrowObj&gt;::create(resultsetArg-&gt;conn)), statement(statementArg),
          resultset(resultsetArg)
{
    all_rows.rows.push_back(current_row);
    resultsetArg-&gt;join_bind_prefetched_row(all_rows.rows);
}
</xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorObj::iteratorObj(const const_</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text> &amp;resultsetArg)
        : current_row(@LIBCXX_NAMESPACE@::ref&lt;</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>::base::prefetchedrowObj&gt;::create(resultsetArg-&gt;conn)), resultset(resultsetArg) {}
</xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorObj::~iteratorObj() noexcept {}

</xsl:text>

    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorObj::postoper_helper </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::iteratorObj::before_postoper()
    {
        return postoper_helper(current_row-&gt;row);
    }

</xsl:text>

    <!-- Row object code -->

    <xsl:call-template name="class" />
    <xsl:text>Base::rowObj::rowObj(const @LIBCXX_NAMESPACE@::sql::connection &amp;connArg) : @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::rowObj(connArg) {}

</xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::rowObj::~rowObj() noexcept {}

    void </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::rowObj::fetched_this_row()
{
</xsl:text>
      <xsl:for-each select="column">
          <xsl:text>    </xsl:text>
	  <xsl:value-of select="@name" />
	  <xsl:text>.original=</xsl:text>
	  <xsl:value-of select="@name" />
	  <xsl:text>.scalar;
</xsl:text>
      </xsl:for-each>
      <xsl:text>}

bool </xsl:text>
    <xsl:call-template name="class" />
    <xsl:text>Base::rowObj::update()
{
    auto updated_contents=@LIBCXX_NAMESPACE@::ref&lt;@LIBCXX_NAMESPACE@::sql::dbi::constraintObj::andObj&gt;::create();

</xsl:text>
      <xsl:for-each select="column">
        <xsl:text>    if (this-&gt;</xsl:text>
	<xsl:value-of select="@name" />
	<xsl:text>.updated()) { updated_contents-&gt;add(</xsl:text>
	<xsl:value-of select="$class" />
	<xsl:text>_JoinsObj::columns[</xsl:text>
	<xsl:value-of select="position()-1" />
	<xsl:text>], "=", this-&gt;</xsl:text>
	<xsl:value-of select="@name" />
	<xsl:text>.scalar); }
</xsl:text>
      </xsl:for-each>
      <xsl:text>

    if (updated_contents-&gt;empty()) return false;

    auto primary_key_values=@LIBCXX_NAMESPACE@::ref&lt;@LIBCXX_NAMESPACE@::sql::dbi::constraintObj::andObj&gt;::create();

</xsl:text>
      <xsl:for-each select="column[@primarykey]">
        <xsl:text>    primary_key_values-&gt;add(</xsl:text>
	<xsl:value-of select="$class" />
	<xsl:text>Obj::primarykeycolumns[</xsl:text>
	<xsl:value-of select="position()-1" />
	<xsl:text>], "=", this-&gt;</xsl:text>
	<xsl:value-of select="@name" />
	<xsl:text>.original);
</xsl:text>
      </xsl:for-each>
    <xsl:text>

    auto rs=</xsl:text>
    <xsl:value-of select="$class" />
    <xsl:text>::create(this-&gt;@LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::rowObj::conn);

    rs-&gt;search(primary_key_values);
    rs-&gt;update(updated_contents);

    // A wise guy could've updated the primary keys...

    primary_key_values=@LIBCXX_NAMESPACE@::ref&lt;@LIBCXX_NAMESPACE@::sql::dbi::constraintObj::andObj&gt;::create();

</xsl:text>
      <xsl:for-each select="column[@primarykey]">
        <xsl:text>    primary_key_values-&gt;add(</xsl:text>
	<xsl:value-of select="$class" />
	<xsl:text>Obj::primarykeycolumns[</xsl:text>
	<xsl:value-of select="position()-1" />
	<xsl:text>], "=", this-&gt;</xsl:text>
	<xsl:value-of select="@name" />
	<xsl:text>.scalar);
</xsl:text>
      </xsl:for-each>
    <xsl:text>

    rs=</xsl:text>
    <xsl:value-of select="$class" />
    <xsl:text>::create(this-&gt;@LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::rowObj::conn);

    rs-&gt;search(primary_key_values);
    auto updated_row=rs-&gt;only();

</xsl:text>
      <xsl:for-each select="column">
        <xsl:text>    this-&gt;</xsl:text>
	<xsl:value-of select="@name" />
	<xsl:text>=updated_row-&gt;</xsl:text>
	<xsl:value-of select="@name" />
	<xsl:text>;
</xsl:text>
      </xsl:for-each>
    <xsl:text>

    return true;
}
</xsl:text>

    <xsl:for-each select="join">

      <xsl:value-of select="@class" />
      <xsl:text> </xsl:text>
      <xsl:value-of select="$class" />
      <xsl:text>Base::rowObj::join_rs_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() const
{
    auto resultset=</xsl:text>
      <xsl:value-of select="@class" />
      <xsl:text>::create(this-&gt;conn);

    resultset-&gt;search(</xsl:text>
      <xsl:for-each select="column">
	<xsl:if test="position() &gt; 1">
	  <xsl:text>,</xsl:text>
	</xsl:if>
	<xsl:text>
        resultset-&gt;get_table_alias() + ".</xsl:text>
        <xsl:call-template name="get-foreign-column-name" />
        <xsl:text>", "=", this-&gt;</xsl:text>
	<xsl:value-of select="." />
	<xsl:text>.scalar</xsl:text>
      </xsl:for-each>
      <xsl:text>    );

    return resultset;
}
</xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text>::base::rowptr </xsl:text>
      <xsl:value-of select="$class" />
      <xsl:text>Base::rowObj::join_maybe_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() const
{
    decltype(join_row_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>)::lock lock(join_row_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>);

    if (!lock-&gt;cached)
    {
        lock-&gt;row=join_rs_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>()-&gt;maybe();
        lock-&gt;cached=true;
    }

    return lock-&gt;row;
}

</xsl:text>

      <xsl:value-of select="@class" />
      <xsl:text>::base::row </xsl:text>
      <xsl:value-of select="$class" />
      <xsl:text>Base::rowObj::join_only_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>() const
{
    auto row=join_maybe_</xsl:text>
      <xsl:call-template name="joinname" />
      <xsl:text>();

    if (row.null())
       @LIBCXX_NAMESPACE@::sql::dbi::resultsetObj::no_rows();

    return row;
}

</xsl:text>
    </xsl:for-each>
  </xsl:template>
</xsl:stylesheet>
