/*
** Copyright 2013 Double Precision, Inc.
** See COPYING for distribution information.
*/

#include "libcxx_config.h"
#include "sql_internal.H"
#include <algorithm>
#include <cstring>
#include <sstream>
#include "gettext_in.h"
#include "x/exception.H"

LOG_CLASS_INIT(LIBCXX_NAMESPACE::sql::connectionimplObj);

namespace LIBCXX_NAMESPACE {
	namespace sql {
#if 0
	}
};
#endif

connectionObj::connectionObj()
{
}

connectionObj::~connectionObj() noexcept
{
}

void connectionObj::begin_work()
{
	begin_work("");
}

connectionimplObj::connectionimplObj(ref<envimplObj> &&envArg)
	: h(nullptr), connected(false), transaction_scope_level(0),
	  env(std::move(envArg))
{
	if (!SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_DBC, env->h, &h)))
	{
		h=nullptr;
		sql_error("SQLAllocHandle", env->h, SQL_HANDLE_ENV);
	}
}

connectionimplObj::~connectionimplObj() noexcept
{
	try {
		disconnect();
	} catch (const LIBCXX_NAMESPACE::exception &e) {
		LOG_ERROR(e);
		LOG_TRACE(e->backtrace);
	}
	if (h)
		SQLFreeHandle(SQL_HANDLE_DBC, h);
}

// Check the error from an SQL connection handle call

// Throw an exception if there was an error. Log a diagnostic at the warning
// level.

void connectionimplObj::ret(SQLRETURN ret, const char *func)
{
	if (!SQL_SUCCEEDED(ret))
		sql_error(func, h, SQL_HANDLE_DBC);

	if (ret == SQL_SUCCESS_WITH_INFO)
	{
		diagnostics diags(func, h, SQL_HANDLE_DBC);

		LOG_WARNING(diags.e);
	}
}

// Retrieve numerical SQLGetInfo values.

template<typename ret_type>
void connectionimplObj::getinfo(SQLUSMALLINT what, const char *what_str,
				ret_type &val)
{
	std::lock_guard<std::mutex> lock(objmutex);

	SQLSMALLINT length_ret;

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(&val),
		       sizeof(val), &length_ret), what_str);

	if (length_ret != sizeof(val))
		throw EXCEPTION("Internal error: type mismatch for "
				+ std::string(what_str));
}

// Retrieve a std::string SQLGetInfo variable

template<>
void connectionimplObj::getinfo<std::string>(SQLUSMALLINT what, const char *what_str,
					     std::string &val)
{
	std::lock_guard<std::mutex> lock(objmutex);

	SQLSMALLINT length_ret;

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(0), 0,
		       &length_ret), what_str);

	val.resize(length_ret+1);

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(&val[0]),
		       length_ret+1,
		       &length_ret), what_str);
	val.resize(length_ret);
}

// Retrieve a bool getinfo variable

template<>
void connectionimplObj::getinfo<bool>(SQLUSMALLINT what, const char *what_str,
				      bool &val)
{
	std::string v;

	getinfo(what, what_str, v);
	val=v == "Y";
}

// Let getinfo_internal.H generate code for all known SQLGetInfo variables,
// depending on the value types.

#define IMPL_GET_INFO_common(v, vs, t)		\
	{					\
		t retval;			\
		getinfo<t>(v, vs, retval);	\
		return retval;			\
	}

#define IMPL_GETINFO_bool(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, bool)

#define IMPL_GETINFO_SQLUSMALLINT(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLUSMALLINT)

#define IMPL_GETINFO_SQLUINTEGER(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLUINTEGER)

#define IMPL_GETINFO_SQLULEN(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLULEN)

#define IMPL_GETINFO_SQLINTEGER(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLINTEGER)

#define IMPL_GETINFO_STRING(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, std::string)

#define IMPL_GETINFO_ENUM(v, vs, t, e)			\
	{						\
		t bitmask;				\
		getinfo<t>(v, vs, bitmask);		\
							\
		config_bitmask_t retval;		\
							\
		e					\
							\
		return retval;				\
	 }

#define LIBCXX_SQL_GETINFO_DECL(t,n) t connectionimplObj::n()
#define LIBCXX_SQL_GETINFO_IMPL(a,b,c,d) IMPL_GETINFO_ ## b (a, #a, c, d)
#define E(n) if (bitmask & n) retval.insert(# n);

// Autogenerated config settings.

#include "getinfo_internal.H"
#undef LIBCXX_SQL_GETINFO_DECL
#undef LIBCXX_SQL_GETINFO_IMPL

void connectionimplObj::disconnect()
{
	std::lock_guard<std::mutex> lock(objmutex);

	do_disconnect();
}

void connectionimplObj::do_disconnect()
{
	if (!connected)
		return;

	connected=false;
	ret(SQLDisconnect(h), "SQLDisconnect");
}

//////////////////////////////////////////////////////////////////////////////
//
// Create a statement handle for various catalog functions

statement connectionimplObj::tables_catalog(bool literal_ids,
					    const std::string &catalog,
					    const std::string &schema,
					    const std::string &table,
					    const std::string &type)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLTables(s->h,
			 to_sqlcharptr_null(catalog), SQL_NTS,
			 to_sqlcharptr_null(schema), SQL_NTS,
			 to_sqlcharptr_null(table), SQL_NTS,
			 to_sqlcharptr_null(type), SQL_NTS), "SQLTables");

	return s;
}

// Common shortcuts

statement connectionimplObj::prepare(const std::string &sql)
{
	return create_newstatement()->prepare(sql);
}

newstatement connectionimplObj::create_newstatement()
{
	return do_create_newstatement();
}

ref<newstatementimplObj> connectionimplObj::do_create_newstatement()
{
	return ref<newstatementimplObj>::create(ref<connectionimplObj>(this));
}

void connectionimplObj::set_attribute_uint(SQLINTEGER attribute,
					   const char *attribute_str,
					   SQLUINTEGER v)
{
	ret(SQLSetConnectAttr(h, attribute, (SQLPOINTER)(SQLULEN)v, 0),
	    attribute_str);
}

void connectionimplObj::autocommit(bool value)
{
	std::lock_guard<std::mutex> lock(objmutex);

	check_not_transaction_scope_level("autocommit");
	CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, value ? SQL_AUTOCOMMIT_ON:SQL_AUTOCOMMIT_OFF);
}

void connectionimplObj::commit(bool turn_on_autocommit)
{
	std::lock_guard<std::mutex> lock(objmutex);

	check_not_transaction_scope_level("commit");
	ret(SQLEndTran(SQL_HANDLE_DBC, h, SQL_COMMIT), "SQLEndTran");

	if (turn_on_autocommit)
		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_ON);
}

void connectionimplObj::rollback(bool turn_on_autocommit)
{
	std::lock_guard<std::mutex> lock(objmutex);

	check_not_transaction_scope_level("rollback");
	ret(SQLEndTran(SQL_HANDLE_DBC, h, SQL_ROLLBACK), "SQLEndTran");

	if (turn_on_autocommit)
		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_ON);
}

void connectionimplObj::check_not_transaction_scope_level(const char *func)
{
	if (!transaction_scope_level)
		return;

	throw EXCEPTION((std::string)
			gettextmsg(_TXT(_txt("%1%() invoked in a middle of a transaction")),
				   func));
}

std::string connectionimplObj::savepoint_name()
{
	std::ostringstream o;

	o << "LIBCXX_SAVEPOINT" << transaction_scope_level;

	return o.str();
}

void connectionimplObj::begin_work(const std::string &options)
{
	// Need to create these before taking the lock

	auto newstmt=do_create_newstatement();
	auto stmt=newstmt->newstmt();

	std::lock_guard<std::mutex> lock(objmutex);

	if (transaction_scope_level == 0)
	{
		// Initial transaction

		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_ON);

		std::string sql="START TRANSACTION";

		if (!options.empty())
			sql += " ";

		newstmt->prepare(stmt, sql + options)->execute();
	}
	else
	{
		// Nested transaction implemented using a savepoint

		if (!(transaction_scope_level+1))
			throw EXCEPTION(_TXT(_txt("Transaction scope level exceeds maximum")));
		newstmt->prepare(stmt, "SAVEPOINT " + savepoint_name())
			->execute();
	}
	++transaction_scope_level;
}

void connectionimplObj::commit_work()
{
	// Need to create these before taking the lock

	auto newstmt=do_create_newstatement();
	auto stmt=newstmt->newstmt();

	std::lock_guard<std::mutex> lock(objmutex);

	commit_rollback_work(newstmt, stmt,
			     --transaction_scope_level
			     ? "RELEASE SAVEPOINT "+savepoint_name()
			     : "COMMIT WORK");
}

void connectionimplObj::rollback_work()
{
	auto newstmt=do_create_newstatement();
	auto stmt=newstmt->newstmt();

	std::lock_guard<std::mutex> lock(objmutex);

	commit_rollback_work(newstmt, stmt,
			     --transaction_scope_level
			     ? "ROLLBACK TO SAVEPOINT "+savepoint_name()
			     : "ROLLBACK WORK");
}

void connectionimplObj::commit_rollback_work(const ref<newstatementimplObj>
					     &stmt,
					     const ref<statementimplObj>
					     &newstmt,
					     const std::string &cmd)
{
	try {
		stmt->prepare(newstmt, cmd)->execute();
	} catch (...) {

		// If we fail here, the connection is in an unknown state.
		// Just give up.

		try {
			do_disconnect();
		} catch (const LIBCXX_NAMESPACE::exception &e) {
			LOG_ERROR(e);
			LOG_TRACE(e->backtrace);
		}

		throw;
	}
}

transaction::transaction(const connection &connArg) : conn(connArg),
						      committed(true)
{
	conn->begin_work();
	committed=false;
}

void transaction::commit_work()
{
	committed=true;
	conn->commit_work();
}

void transaction::rollback_work()
{
	committed=true;
	conn->rollback_work();
}

LOG_FUNC_SCOPE_DECL(LIBCXX_NAMESPACE::sql::transaction::~transaction,
		    transactionDestructor);

transaction::~transaction() noexcept
{
	LOG_FUNC_SCOPE(transactionDestructor);

	if (!committed)
	{
		try {
			rollback_work();
		} catch (const LIBCXX_NAMESPACE::exception &e)
		{
			LOG_ERROR(e);
			LOG_TRACE(e->backtrace);
		}
	}
};

#if 0
{
	{
#endif
	};
};
