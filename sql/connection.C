/*
** Copyright 2013 Double Precision, Inc.
** See COPYING for distribution information.
*/

#include "libcxx_config.h"
#include "sql_internal.H"
#include <algorithm>
#include <cstring>
#include <sstream>
#include "gettext_in.h"
#include "x/exception.H"

LOG_CLASS_INIT(LIBCXX_NAMESPACE::sql::connectionimplObj);

namespace LIBCXX_NAMESPACE {
	namespace sql {
#if 0
	}
};
#endif

connectionObj::connectionObj()
{
}

connectionObj::~connectionObj() noexcept
{
}

connectionimplObj::connectionimplObj(ref<envimplObj> &&envArg)
	: h(nullptr), connected(false), env(std::move(envArg))
{
	if (!SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_DBC, env->h, &h)))
	{
		h=nullptr;
		sql_error("SQLAllocHandle", env->h, SQL_HANDLE_ENV);
	}
}

connectionimplObj::~connectionimplObj() noexcept
{
	try {
		disconnect();
	} catch (const LIBCXX_NAMESPACE::exception &e) {
		LOG_ERROR(e);
		LOG_TRACE(e->backtrace);
	}
	if (h)
		SQLFreeHandle(SQL_HANDLE_DBC, h);
}

// Check the error from an SQL connection handle call

// Throw an exception if there was an error. Log a diagnostic at the warning
// level.

void connectionimplObj::ret(SQLRETURN ret, const char *func)
{
	if (!SQL_SUCCEEDED(ret))
		sql_error(func, h, SQL_HANDLE_DBC);

	if (ret == SQL_SUCCESS_WITH_INFO)
	{
		diagnostics diags(func, h, SQL_HANDLE_DBC);

		LOG_WARNING(diags.e);
	}
}

// Retrieve numerical SQLGetInfo values.

template<typename ret_type>
void connectionimplObj::getinfo(SQLUSMALLINT what, const char *what_str,
				ret_type &val)
{
	std::lock_guard<std::mutex> lock(objmutex);

	SQLSMALLINT length_ret;

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(&val),
		       sizeof(val), &length_ret), what_str);

	if (length_ret != sizeof(val))
		throw EXCEPTION("Internal error: type mismatch for "
				+ std::string(what_str));
}

// Retrieve a std::string SQLGetInfo variable

template<>
void connectionimplObj::getinfo<std::string>(SQLUSMALLINT what, const char *what_str,
					     std::string &val)
{
	std::lock_guard<std::mutex> lock(objmutex);

	SQLSMALLINT length_ret;

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(0), 0,
		       &length_ret), what_str);

	val.resize(length_ret+1);

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(&val[0]),
		       length_ret+1,
		       &length_ret), what_str);
	val.resize(length_ret);
}

// Retrieve a bool getinfo variable

template<>
void connectionimplObj::getinfo<bool>(SQLUSMALLINT what, const char *what_str,
				      bool &val)
{
	std::string v;

	getinfo(what, what_str, v);
	val=v == "Y";
}

// Let getinfo_internal.H generate code for all known SQLGetInfo variables,
// depending on the value types.

#define IMPL_GET_INFO_common(v, vs, t)		\
	{					\
		t retval;			\
		getinfo<t>(v, vs, retval);	\
		return retval;			\
	}

#define IMPL_GETINFO_bool(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, bool)

#define IMPL_GETINFO_SQLUSMALLINT(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLUSMALLINT)

#define IMPL_GETINFO_SQLUINTEGER(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLUINTEGER)

#define IMPL_GETINFO_SQLULEN(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLULEN)

#define IMPL_GETINFO_SQLINTEGER(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLINTEGER)

#define IMPL_GETINFO_STRING(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, std::string)

#define IMPL_GETINFO_ENUM(v, vs, t, e)			\
	{						\
		t bitmask;				\
		getinfo<t>(v, vs, bitmask);		\
							\
		config_bitmask_t retval;		\
							\
		e					\
							\
		return retval;				\
	 }

#define LIBCXX_SQL_GETINFO_DECL(t,n) t connectionimplObj::n()
#define LIBCXX_SQL_GETINFO_IMPL(a,b,c,d) IMPL_GETINFO_ ## b (a, #a, c, d)
#define E(n) if (bitmask & n) retval.insert(# n);

// Autogenerated config settings.

#include "getinfo_internal.H"
#undef LIBCXX_SQL_GETINFO_DECL
#undef LIBCXX_SQL_GETINFO_IMPL

void connectionimplObj::disconnect()
{
	std::lock_guard<std::mutex> lock(objmutex);

	do_disconnect();
}

void connectionimplObj::do_disconnect()
{
	if (!connected)
		return;

	connected=false;
	ret(SQLDisconnect(h), "SQLDisconnect");
}

//////////////////////////////////////////////////////////////////////////////
//
// Create a statement handle for various catalog functions

statement connectionimplObj::tables_catalog(bool literal_ids,
					    const std::string &catalog,
					    const std::string &schema,
					    const std::string &table,
					    const std::string &type)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLTables(s->h,
			 to_sqlcharptr_null(catalog), SQL_NTS,
			 to_sqlcharptr_null(schema), SQL_NTS,
			 to_sqlcharptr_null(table), SQL_NTS,
			 to_sqlcharptr_null(type), SQL_NTS), "SQLTables");

	return s;
}

// Common shortcuts

statement connectionimplObj::prepare(const std::string &sql)
{
	return create_newstatement()->prepare(sql);
}

newstatement connectionimplObj::create_newstatement()
{
	return do_create_newstatement();
}

ref<newstatementimplObj> connectionimplObj::do_create_newstatement()
{
	return ref<newstatementimplObj>::create(ref<connectionimplObj>(this));
}

void connectionimplObj::set_attribute_uint(SQLINTEGER attribute,
					   const char *attribute_str,
					   SQLUINTEGER v)
{
	ret(SQLSetConnectAttr(h, attribute, (SQLPOINTER)(SQLULEN)v, 0),
	    attribute_str);
}

#if 0
{
	{
#endif
	};
};
