/*
** Copyright 2013 Double Precision, Inc.
** See COPYING for distribution information.
*/

#include "libcxx_config.h"
#include "sql_internal.H"
#include "x/sql/dbi/flavor.H"
#include <algorithm>
#include <cstring>
#include <sstream>
#include "gettext_in.h"
#include "x/exception.H"

LOG_CLASS_INIT(LIBCXX_NAMESPACE::sql::execute);

namespace LIBCXX_NAMESPACE {
	namespace sql {
#if 0
	}
};
#endif

connectionObj::connectionObj()
{
}

connectionObj::~connectionObj()
{
}

void connectionObj::begin_work()
{
	begin_work("");
}

connectionimplObj::connectionimplObj(ref<envimplObj> &&envArg)
	: h(nullptr), connected(false), transaction_scope_level(0),
	  env(std::move(envArg))
{
	if (!SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_DBC, env->h, &h)))
	{
		h=nullptr;
		sql_error("SQLAllocHandle", env->h, SQL_HANDLE_ENV);
	}
}

connectionimplObj::~connectionimplObj()
{
	LOG_FUNC_SCOPE(execute::logger);

	try {
		disconnect();
	} catch (const LIBCXX_NAMESPACE::exception &e) {
		LOG_ERROR(e);
		LOG_TRACE(e->backtrace);
	}
	if (h)
		SQLFreeHandle(SQL_HANDLE_DBC, h);
}

connection connectionimplObj::clone() const
{
	return env->envObj::connect(connstring).first;
}

// Check the error from an SQL connection handle call

// Throw an exception if there was an error. Log a diagnostic at the warning
// level.

void connectionimplObj::ret(SQLRETURN ret, const char *func)
{
	LOG_FUNC_SCOPE(execute::logger);

	if (!SQL_SUCCEEDED(ret))
		sql_error(func, h, SQL_HANDLE_DBC);

	if (ret == SQL_SUCCESS_WITH_INFO)
	{
		diagnostics diags(func, h, SQL_HANDLE_DBC);

		LOG_WARNING(diags.e);
	}
}

// Retrieve numerical SQLGetInfo values.

template<typename ret_type>
void connectionimplObj::getinfo(SQLUSMALLINT what, const char *what_str,
				ret_type &val)
{
	std::lock_guard<std::mutex> lock(objmutex);

	SQLSMALLINT length_ret;

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(&val),
		       sizeof(val), &length_ret), what_str);

	if (length_ret != sizeof(val))
		throw EXCEPTION("Internal error: type mismatch for "
				+ std::string(what_str));
}

// Retrieve a std::string SQLGetInfo variable

template<>
void connectionimplObj::getinfo<std::string>(SQLUSMALLINT what, const char *what_str,
					     std::string &val)
{
	std::lock_guard<std::mutex> lock(objmutex);

	SQLSMALLINT length_ret;

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(0), 0,
		       &length_ret), what_str);

	val.resize(length_ret+1);

	ret(SQLGetInfo(h, what, reinterpret_cast<SQLPOINTER>(&val[0]),
		       length_ret+1,
		       &length_ret), what_str);
	val.resize(length_ret);
}

// Retrieve a bool getinfo variable

template<>
void connectionimplObj::getinfo<bool>(SQLUSMALLINT what, const char *what_str,
				      bool &val)
{
	std::string v;

	getinfo(what, what_str, v);
	val=v == "Y";
}

// Let getinfo_internal.H generate code for all known SQLGetInfo variables,
// depending on the value types.

#define IMPL_GET_INFO_common(v, vs, t)		\
	{					\
		t retval;			\
		getinfo<t>(v, vs, retval);	\
		return retval;			\
	}

#define IMPL_GETINFO_bool(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, bool)

#define IMPL_GETINFO_SQLUSMALLINT(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLUSMALLINT)

#define IMPL_GETINFO_SQLUINTEGER(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLUINTEGER)

#define IMPL_GETINFO_SQLULEN(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLULEN)

#define IMPL_GETINFO_SQLINTEGER(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, SQLINTEGER)

#define IMPL_GETINFO_STRING(v, vs, c, d)		\
	IMPL_GET_INFO_common(v, vs, std::string)

#define IMPL_GETINFO_ENUM(v, vs, t, e)			\
	{						\
		t bitmask;				\
		getinfo<t>(v, vs, bitmask);		\
							\
		config_bitmask_t retval;		\
							\
		e					\
							\
		return retval;				\
	 }

#define LIBCXX_SQL_GETINFO_DECL(t,n) t connectionimplObj::n()
#define LIBCXX_SQL_GETINFO_IMPL(a,b,c,d) IMPL_GETINFO_ ## b (a, #a, c, d)
#define E(n) if (bitmask & n) retval.insert(# n);

// Autogenerated config settings.

#include "getinfo_internal.H"
#undef LIBCXX_SQL_GETINFO_DECL
#undef LIBCXX_SQL_GETINFO_IMPL

void connectionimplObj::disconnect()
{
	std::lock_guard<std::mutex> lock(objmutex);

	do_disconnect();
}

void connectionimplObj::do_disconnect()
{
	if (!connected)
		return;

	connected=false;
	ret(SQLDisconnect(h), "SQLDisconnect");
}

//////////////////////////////////////////////////////////////////////////////
//
// Create a statement handle for various catalog functions

statement connectionObj::tables()
{
	return tables_catalog(false);
}

statement connectionObj::columns()
{
	return columns_catalog(false);
}

statement connectionObj::column_privileges()
{
	return column_privileges_catalog(false);
}

statement connectionObj::foreign_keys()
{
	return foreign_keys_catalog(false);
}

statement connectionObj::procedure_columns()
{
	return procedure_columns_catalog(false);
}

statement connectionObj::procedures()
{
	return procedures_catalog(false);
}

statement connectionimplObj::tables_catalog(bool literal_ids,
					    const std::string &catalog,
					    const std::string &schema,
					    const std::string &table,
					    const std::string &type)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLTables(s->h,
			 to_sqlcharptr_null(catalog), SQL_NTS,
			 to_sqlcharptr_null(schema), SQL_NTS,
			 to_sqlcharptr_null(table), SQL_NTS,
			 to_sqlcharptr_null(type), SQL_NTS), "SQLTables");

	return s;
}

statement connectionimplObj::table_privileges_catalog(bool literal_ids,
						      const std::string &table,
						      const std::string &catalog,
						      const std::string &schema)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLTablePrivileges(s->h,
				  to_sqlcharptr_null(catalog), SQL_NTS,
				  to_sqlcharptr_null(schema), SQL_NTS,
				  to_sqlcharptr(table), SQL_NTS),
	       "SQLTablePrivileges");

	return s;
}

statement connectionimplObj::columns_catalog(bool literal_ids,
					     const std::string &catalog,
					     const std::string &schema,
					     const std::string &table,
					     const std::string &columnname)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLColumns(s->h,
			  to_sqlcharptr_null(catalog), SQL_NTS,
			  to_sqlcharptr_null(schema), SQL_NTS,
			  to_sqlcharptr_null(table), SQL_NTS,
			  to_sqlcharptr_null(columnname), SQL_NTS),
	       "SQLColumns");

	return s;
}

statement connectionimplObj::column_privileges_catalog(bool literal_ids,
						       const std::string &catalog,
						       const std::string &schema,
						       const std::string &table,
						       const std::string &columnname)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLColumnPrivileges(s->h,
				   to_sqlcharptr_null(catalog), SQL_NTS,
				   to_sqlcharptr_null(schema), SQL_NTS,
				   to_sqlcharptr(table), SQL_NTS,
				   to_sqlcharptr_null(columnname), SQL_NTS),
	       "SQLColumnPrivileges");

	return s;
}

statement connectionimplObj::primary_keys_catalog(bool literal_ids,
						  const std::string &table,
						  const std::string &catalog,
						  const std::string &schema)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLPrimaryKeys(s->h,
			      to_sqlcharptr_null(catalog), SQL_NTS,
			      to_sqlcharptr_null(schema), SQL_NTS,
			      to_sqlcharptr(table), SQL_NTS),
	       "SQLPrimaryKeys");

	return s;
}

statement connectionimplObj::foreign_keys_catalog(bool literal_ids,
						  const std::string &pk_catalog,
						  const std::string &pk_schema,
						  const std::string &pk_table,
						  const std::string &fk_catalog,
						  const std::string &fk_schema,
						  const std::string &fk_table)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);
	s->ret(SQLForeignKeys(s->h,
			      to_sqlcharptr_null(pk_catalog), SQL_NTS,
			      to_sqlcharptr_null(pk_schema), SQL_NTS,
			      to_sqlcharptr_null(pk_table), SQL_NTS,
			      to_sqlcharptr_null(fk_catalog), SQL_NTS,
			      to_sqlcharptr_null(fk_schema), SQL_NTS,
			      to_sqlcharptr_null(fk_table), SQL_NTS),
	       "SQLForeignKeys");

	return s;
}

statement connectionimplObj::procedure_columns_catalog(bool literal_ids,
						       const std::string &catalog,
						       const std::string &schema,
						       const std::string &proc,
						       const std::string &column)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);

	s->ret(SQLProcedureColumns(s->h,
				   to_sqlcharptr(catalog), SQL_NTS,
				   to_sqlcharptr(schema), SQL_NTS,
				   to_sqlcharptr(proc), SQL_NTS,
				   to_sqlcharptr(column), SQL_NTS),
	       "SQLProcedureColumns");

	return s;
}

statement connectionimplObj::procedures_catalog(bool literal_ids,
						const std::string &catalog,
						const std::string &schema,
						const std::string &proc)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);

	s->ret(SQLProcedures(s->h,
			     to_sqlcharptr(catalog), SQL_NTS,
			     to_sqlcharptr(schema), SQL_NTS,
			     to_sqlcharptr(proc), SQL_NTS),
	       "SQLProcedures");

	return s;
}

statement connectionimplObj::special_columns_catalog(bool literal_ids,
						     rowid_t rowid,
						     scope_t scope,
						     const std::string &table,
						     bool nullable,
						     const std::string &catalog,
						     const std::string &schema
						     )
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);

	s->ret(SQLSpecialColumns(s->h,
				 rowid == rowid_t::unique ?
				 SQL_BEST_ROWID:SQL_ROWVER,
				 to_sqlcharptr_null(catalog), SQL_NTS,
				 to_sqlcharptr_null(schema), SQL_NTS,
				 to_sqlcharptr(table), SQL_NTS,
				 scope == scope_t::currow ?
				 SQL_SCOPE_CURROW:
				 scope == scope_t::transaction ?
				 SQL_SCOPE_TRANSACTION:SQL_SCOPE_SESSION,
				 nullable ? SQL_NULLABLE:SQL_NO_NULLS
				 ),
	       "SQLSpecialColumns");

	return s;
}

statement connectionimplObj::statistics_catalog(bool literal_ids,
						const std::string &table,
						bool unique_only,
						bool force,
						const std::string &catalog,
						const std::string &schema
						)
{
	auto s=do_create_newstatement()->newstmt();

	s->SET_ATTR(SQL_ATTR_METADATA_ID, ulen, literal_ids ? SQL_TRUE:SQL_FALSE);

	s->ret(SQLStatistics(s->h,
			     to_sqlcharptr_null(catalog), SQL_NTS,
			     to_sqlcharptr_null(schema), SQL_NTS,
			     to_sqlcharptr(table), SQL_NTS,
			     unique_only ? SQL_INDEX_UNIQUE:SQL_INDEX_ALL,
			     force ? SQL_ENSURE:SQL_QUICK), "SQLStatistics");

	return s;
}

statement connectionimplObj::type_info()
{
	return type_info(std::string());
}

statement connectionimplObj::type_info(const std::string &name)
{
	SQLSMALLINT t=SQL_ALL_TYPES;

	if (!name.empty())
	{
		auto tn=name_to_type(name.c_str());

		if (tn == SQL_UNKNOWN_TYPE)
			throw EXCEPTION((std::string)
					gettextmsg(_TXT(_txt("\"%1%\" is not a valid SQL type")),
						   name));
		t=tn;
	}

	auto s=do_create_newstatement()->newstmt();
	s->ret(SQLGetTypeInfo(s->h, t), "SQLGetTypeInfo");

	return s;
}

// Common shortcuts

statement connectionimplObj::prepare(const std::string &sql)
{
	return create_newstatement()->prepare(sql);
}

newstatement connectionimplObj::create_newstatement()
{
	return do_create_newstatement();
}

ref<newstatementimplObj> connectionimplObj::do_create_newstatement()
{
	return ref<newstatementimplObj>::create(ref<connectionimplObj>(this));
}

statement connectionimplObj::execute_directly(const std::string_view &sql)
{
	auto s=ref<statementimplObj>::create(ref(this));

	ret(SQLExecDirect(s->h, to_sqlcharptr(sql), sql.size()),
	    "SQLExecDirect");

	return s;
}

void connectionimplObj::set_attribute_uint(SQLINTEGER attribute,
					   const char *attribute_str,
					   SQLUINTEGER v)
{
	ret(SQLSetConnectAttr(h, attribute, (SQLPOINTER)(SQLULEN)v, 0),
	    attribute_str);
}

void connectionimplObj::autocommit(bool value)
{
	std::lock_guard<std::mutex> lock(objmutex);

	check_not_transaction_scope_level("autocommit");
	CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, value ? SQL_AUTOCOMMIT_ON:SQL_AUTOCOMMIT_OFF);
}

void connectionimplObj::commit(bool turn_on_autocommit)
{
	std::lock_guard<std::mutex> lock(objmutex);

	check_not_transaction_scope_level("commit");
	ret(SQLEndTran(SQL_HANDLE_DBC, h, SQL_COMMIT), "SQLEndTran");

	if (turn_on_autocommit)
		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_ON);
}

void connectionimplObj::rollback(bool turn_on_autocommit)
{
	std::lock_guard<std::mutex> lock(objmutex);

	check_not_transaction_scope_level("rollback");
	ret(SQLEndTran(SQL_HANDLE_DBC, h, SQL_ROLLBACK), "SQLEndTran");

	if (turn_on_autocommit)
		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_ON);
}

void connectionimplObj::check_not_transaction_scope_level(const char *func)
{
	if (!transaction_scope_level)
		return;

	throw EXCEPTION((std::string)
			gettextmsg(_TXT(_txt("%1%() invoked in a middle of a transaction")),
				   func));
}

std::string connectionimplObj::savepoint_name()
{
	std::ostringstream o;

	o << "LIBCXX_SAVEPOINT" << transaction_scope_level;

	return o.str();
}

void connectionimplObj::begin_work(const std::string &options)
{
	std::lock_guard<std::mutex> lock(objmutex);

	if (transaction_scope_level == 0)
	{
		// Initial transaction

		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_OFF);
	}
	else
	{
		// Nested transaction implemented using a savepoint

		if (!(transaction_scope_level+1))
			throw EXCEPTION(_TXT(_txt("Transaction scope level exceeds maximum")));
		execute_directly("SAVEPOINT " + savepoint_name());
	}
	++transaction_scope_level;
}

void connectionimplObj::commit_work()
{
	std::lock_guard<std::mutex> lock(objmutex);

	if (transaction_scope_level == 0)
		throw EXCEPTION(_TXT(_txt("commit_work() called without begin_work")));

	if (--transaction_scope_level == 0)
	{
		ret(SQLEndTran(SQL_HANDLE_DBC, h, SQL_COMMIT), "SQLEndTran");
		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_ON);
	}
	else
		commit_rollback_work("RELEASE SAVEPOINT "+savepoint_name());
}

void connectionimplObj::rollback_work()
{
	std::lock_guard<std::mutex> lock(objmutex);

	if (transaction_scope_level == 0)
		throw EXCEPTION(_TXT(_txt("commit_work() called without begin_work")));
	if (--transaction_scope_level == 0)
	{
		ret(SQLEndTran(SQL_HANDLE_DBC, h, SQL_ROLLBACK), "SQLEndTran");
		CONN_ATTR(SQL_ATTR_AUTOCOMMIT, uint, SQL_AUTOCOMMIT_ON);
	}
	else
	{
		commit_rollback_work("ROLLBACK TO SAVEPOINT "+savepoint_name());
	}
}

void connectionimplObj::commit_rollback_work(const std::string &cmd)
{
	try {
		execute_directly(cmd);
	} catch (...) {

		// If we fail here, the connection is in an unknown state.
		// Just give up.

		try {
			do_disconnect();
		} catch (const LIBCXX_NAMESPACE::exception &e) {
			e->caught();
		}

		throw;
	}
}

transaction::transaction(const connection &connArg) : conn(connArg),
						      committed(true)
{
	conn->begin_work();
	committed=false;
}

void transaction::commit_work()
{
	committed=true;
	conn->commit_work();
}

void transaction::rollback_work()
{
	committed=true;
	conn->rollback_work();
}

transaction::~transaction()
{
	if (!committed)
	{
		try {
			rollback_work();
		} catch (const LIBCXX_NAMESPACE::exception &e)
		{
			e->caught();
		}
	}
};

std::string connectionimplObj::native_sql(const std::string &sql)
{
	SQLINTEGER outlen;

	ret(SQLNativeSql(h, to_sqlcharptr(sql), SQL_NTS,
			 nullptr, 0, &outlen), "SQLNativeSQL");

	SQLCHAR buffer[outlen+1];

	ret(SQLNativeSql(h, to_sqlcharptr(sql), SQL_NTS,
			 buffer, outlen+1, &outlen), "SQLNativeSQL");

	return std::string(buffer, buffer+outlen);
}

#if 0
{
	{
#endif
	};
};
